#!/bin/bash
set -euo pipefail

# git-suggest-message
#
# A git subcommand (invoked as: `git suggest-message`) that uses an LLM to draft
# a commit message from a staged diff, optionally committing it.
#
# Usage:
#   git suggest-message
#   git suggest-message --commit
#   git suggest-message --commit --edit
#   git suggest-message --commit --yes
#
# Notes:
# - If stdin is piped, this command will use stdin as the diff input.
# - Otherwise it uses `git diff --cached`.
# - If `CONTINUITY.md` is included in the diff, it is used as a strong signal.
#
# Env:
# - MINIMAX_CP_KEY (required)
# - MINIMAX_ENDPOINT (optional; default: https://api.minimax.io/anthropic/v1/messages)
# - MINIMAX_MODEL (optional; default: MiniMax-M2.1)

# Global state
COMMIT=false
EDIT=false
YES=false
DEBUG=false
HELP=false

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit) COMMIT=true; shift ;;
            --edit) EDIT=true; shift ;;
            --yes) YES=true; shift ;;
            --debug) DEBUG=true; shift ;;
            --help|-h) HELP=true; shift ;;
            *)
                echo "Unknown argument: $1" >&2
                exit 2
                ;;
        esac
    done

    # Implications
    if $EDIT; then
        COMMIT=true
    fi
    if $YES; then
        COMMIT=true
    fi
}

# Show usage
usage() {
    cat <<EOF
git suggest-message

Draft a commit message using an LLM from a staged diff (or stdin).

USAGE:
  git suggest-message
  git suggest-message --commit
  git suggest-message --commit --edit
  git suggest-message --commit --yes

FLAGS:
  --commit   Commit with the suggested message (after confirmation unless --yes)
  --edit     Open editor before finalizing commit (implies --commit)
  --yes      Skip confirmation prompt (implies --commit)
  --debug    Print extra debug info to stderr
  -h,--help  Show help
EOF
}

# Check if stdin is a TTY
is_stdin_tty() {
    [ -t 0 ]
}

# Read all stdin if piped
read_stdin_if_piped() {
    if is_stdin_tty; then
        echo ""
    else
        cat
    fi
}

# Run git command
run_git() {
    local args=("$@")
    git "${args[@]}"
}

# Parse unified diff by file - returns list of filenames
parse_diff_files() {
    local diff_text="$1"
    echo "$diff_text" | grep '^diff --git a/' | sed 's|^diff --git a/.* b/||' | sed 's| .*$||'
}

# Get diff content for a specific file
get_file_diff() {
    local diff_text="$1"
    local target_file="$2"
    local in_file=false
    local result=""

    while IFS= read -r line; do
        case "$line" in
            diff\ --git\ a/*\ b/*)
                # Extract the b/ path
                local current_file
                current_file=$(echo "$line" | sed 's|^diff --git a/.* b/||' | sed 's| .*$||')
                if [[ "$current_file" == "$target_file" ]]; then
                in_file=true
                echo "$line"
                else
                    in_file=false
                fi
                ;;
            *)
                if $in_file; then
            echo "$line"
                fi
                ;;
        esac
    done <<< "$diff_text"
}

# Pick CONTINUITY.md key from file list
pick_continuity_key() {
    local files=("$@")

    for f in "${files[@]}"; do
        if [[ "$f" == "CONTINUITY.md" ]]; then
            echo "$f"
            return
        fi
    done

    for f in "${files[@]}"; do
        if [[ "$f" == */CONTINUITY.md ]] || [[ "$f" == *//CONTINUITY.md ]]; then
            echo "$f"
            return
        fi
    done

    echo ""
}

# Extract added Done bullets from CONTINUITY.md diff
extract_added_done_bullets() {
    local continuity_diff="$1"
    local in_done=false
    local result=()
    local -A seen

    while IFS= read -r rawLine; do
        # Skip diff metadata lines
        case "$rawLine" in
            diff\ --git\ *|index\ *|---*|+++*|@@*)
                continue
                ;;
        esac

        # Normalize line
        local normalized="${rawLine/# /}"
        normalized="${normalized/#-/}"
        normalized="${normalized/#+/}"

        # Check for Done/Now sections
        case "$normalized" in
            Done*|Done\ *|" Done"*)
                in_done=true
                continue
                ;;
            Now*|Now\ *|" Now"*)
                in_done=false
                continue
                ;;
        esac

        # Extract bullets in Done section
        if $in_done; then
            case "$rawLine" in
                "+  - "*)
                    local bullet="${rawLine#+  - }"
                    bullet=$(echo "$bullet" | xargs)

                    # Deduplicate
                    if [[ -z "${seen[$bullet]:-}" ]]; then
                        seen[$bullet]=1
                        result+=("$bullet")
                    fi
                    ;;
            esac
        fi
    done <<< "$continuity_diff"

    printf '%s\n' "${result[@]}"
}

# Build prompt for LLM
build_prompt() {
    local rawDiff="$1"
    local continuityDiff="$2"
    local continuityBullets="$3"
    local changedFiles="$4"
    local nonContinuityDiff="$5"

    # Format continuity bullets
    local doneBulletsBlock
    if [[ -n "$continuityBullets" ]]; then
        doneBulletsBlock=$(echo "$continuityBullets" | sed 's/^/- /')
    else
        doneBulletsBlock="(none detected)"
    fi

    # Format continuity block
    local continuityBlock
    if [[ -n "$continuityDiff" ]]; then
        continuityBlock=$(echo "$continuityDiff" | sed 's/[[:space:]]*$//')
    else
        continuityBlock="(CONTINUITY.md diff not present in this input)"
    fi

    # Format files block
    local filesBlock
    if [[ -n "$changedFiles" ]]; then
        filesBlock=$(echo "$changedFiles" | sed 's/^/- /')
    else
        filesBlock="(none detected)"
    fi

    # Format non-continuity diff
    local nonContinuityBlock
    if [[ -n "$nonContinuityDiff" ]]; then
        nonContinuityBlock=$(echo "$nonContinuityDiff" | sed 's/[[:space:]]*$//')
    else
        nonContinuityBlock="(none)"
    fi

    # Format raw diff
    local rawDiffBlock
    if [[ -n "$rawDiff" ]]; then
        rawDiffBlock=$(echo "$rawDiff" | sed 's/[[:space:]]*$//')
    else
        rawDiffBlock="(empty)"
    fi

    cat <<PROMPT
You are the commit-message writer for this repository.

Task:
- Suggest a high-quality git commit message based on the staged diff.
- IMPORTANT: Do NOT do code review. Do NOT judge quality/correctness. Only describe intent, scope, and rationale.

Output format:
- Line 1: Conventional Commits subject (e.g. feat(ui): ..., fix(api): ..., refactor: ...)
- Body: at most 7 lines, using this structure:
  Why:
  - ...
  What:
  - ...
  Notes:
  - ... (optional)

Selection rules:
- If CONTINUITY.md "Done:" gained new bullet(s), prioritize those as the source of truth for What (and often the subject).
- Use changed file paths to infer scope (ui/api/workflows/lib/app/etc).
- If multiple distinct changes exist, either:
  - suggest splitting commits (1 line), OR
  - pick the dominant theme and mention the rest briefly in Notes.

Context extracted:
[Changed files]
$filesBlock

[CONTINUITY.md Done bullets added]
$doneBulletsBlock

[CONTINUITY.md diff]
$continuityBlock

[Non-CONTINUITY diffs]
$nonContinuityBlock

[Raw diff (full)]
$rawDiffBlock
PROMPT
}

# Spinner for API call
spinner_pid=""
start_spinner() {
    local message="$1"
    local frames=('-' '\\' '|' '/')
    local i=0

    (
        while true; do
            printf '\r%s%s' "${frames[$i]}" "$message" >&2
            i=$(( (i + 1) % 4 ))
            sleep 0.1
        done
    ) &
    spinner_pid=$!
}

stop_spinner() {
    if [[ -n "$spinner_pid" ]] && kill -0 "$spinner_pid" 2>/dev/null; then
        kill "$spinner_pid" 2>/dev/null || true
        wait "$spinner_pid" 2>/dev/null || true
        printf '\r%40s\r' ' ' >&2
    fi
}

# Call MiniMax API
call_minimax() {
    local content="$1"

    local endpoint="${MINIMAX_ENDPOINT:-https://api.minimax.io/anthropic/v1/messages}"
    local model="${MINIMAX_MODEL:-MiniMax-M2.1}"
    local api_key="${MINIMAX_CP_KEY:-}"

    if [[ -z "$api_key" ]]; then
        echo "Missing MINIMAX_CP_KEY env var." >&2
        exit 1
    fi

    if $DEBUG; then
        echo "[debug] endpoint=$endpoint model=$model" >&2
    fi

    # Start spinner
    start_spinner "Calling API..."

    # Build JSON payload
    local payload
    payload=$(jq -n \
        --arg model "$model" \
        --argjson max_tokens 2048 \
        --arg content "$content" \
        '{
            model: $model,
            max_tokens: $max_tokens,
            messages: [{ role: "user", content: $content }]
        }')

    # Call API
    local response
    response=$(curl -s -X POST "$endpoint" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $api_key" \
        -H "anthropic-version: 2023-06-01" \
        -d "$payload")

    # Stop spinner
    stop_spinner

    # Check for errors
    local http_code
    http_code=$(echo "$response" | jq -r '.error?.type // "success"' 2>/dev/null | tr -d '\n' || echo "success")
    http_code=$(echo "$http_code" | xargs)  # trim whitespace

    case "$http_code" in
        success) ;;
        *)
            local error_msg
            error_msg=$(echo "$response" | jq -r '.error?.message // "Unknown error"' 2>/dev/null | tr -d '\n' | xargs)
            echo "API error: $error_msg" >&2
            exit 1
            ;;
    esac


    # Extract content
    echo "$response" | jq -r '.content[]? | select(.type == "text") | .text' 2>/dev/null | tr -d '\r'
}

# Confirmation prompt
confirm() {
    local prompt="$1"
    local response
    echo -n "$prompt" >&2
    read -r response < /dev/tty 2>/dev/null || true
    response=$(echo "$response" | tr '[:upper:]' '[:lower:]')
    if [[ "$response" == "y" ]] || [[ "$response" == "yes" ]]; then
        return 0
    else
        return 1
    fi
}

# Commit with message
git_commit_with_message() {
    local message="$1"
    local edit="$2"

    local args=("commit" "-F" "-")
    if [[ "$edit" == "true" ]]; then
        args=("commit" "-e" "-F" "-")
    fi

    # Use git commit with stdin
    echo "$message" | git "${args[@]}"
}

# Main
main() {
    parse_args "$@"

    if $HELP; then
        usage
        exit 0
    fi

    # 1) Get diff input
    local piped
    piped=$(read_stdin_if_piped)
    local rawDiff=""

    if [[ -n "$piped" ]]; then
        rawDiff=$(echo "$piped" | xargs)
    fi

    if [[ -z "$rawDiff" ]]; then
        # Nothing piped, use staged diff
        local nameOnly
        nameOnly=$(git diff --cached --name-only)
        if [[ -z "$nameOnly" ]]; then
            echo "Nothing staged. Stage changes first (git add ...)." >&2
            exit 1
        fi
        rawDiff=$(git diff --cached)
    fi

    # 2) Parse CONTINUITY.md signals + file list
    local fileKeys=()
    while IFS= read -r line; do
        fileKeys+=("$line")
    done < <(parse_diff_files "$rawDiff")

    local continuityKey
    continuityKey=$(pick_continuity_key "${fileKeys[@]}")

    local continuityDiff=""
    if [[ -n "$continuityKey" ]]; then
        continuityDiff=$(get_file_diff "$rawDiff" "$continuityKey")
    fi

    local continuityBullets=""
    if [[ -n "$continuityDiff" ]]; then
        continuityBullets=$(extract_added_done_bullets "$continuityDiff")
    fi

    # Build non-continuity diff
    local nonContinuityDiff=""
    if [[ ${#fileKeys[@]} -gt 0 ]]; then
        local first=true
        for k in "${fileKeys[@]}"; do
            if [[ -n "$continuityKey" ]] && [[ "$k" == "$continuityKey" ]]; then
                continue
            fi
            if $first; then
                nonContinuityDiff=$(get_file_diff "$rawDiff" "$k")
                first=false
            else
                nonContinuityDiff=$nonContinuityDiff$'\n\n'$(get_file_diff "$rawDiff" "$k")
            fi
        done
    else
        nonContinuityDiff="$rawDiff"
    fi

    # Format changed files for prompt
    local changedFilesStr
    changedFilesStr=$(printf '%s\n' "${fileKeys[@]}" | grep -v '^$' || true)

    # Build prompt
    local prompt
    prompt=$(build_prompt "$rawDiff" "$continuityDiff" "$continuityBullets" "$changedFilesStr" "$nonContinuityDiff")

    # 3) Call API
    local suggested
    suggested=$(call_minimax "$prompt")

    # Print suggestion
    echo -n "$suggested"

    # 4) Optionally commit
    if ! $COMMIT; then
        exit 0
    fi

    if ! $YES; then
        if ! confirm "Commit with this message? [y/N] "; then
            exit 0
        fi
    fi

    git_commit_with_message "$suggested" "$EDIT"
}

main "$@"
